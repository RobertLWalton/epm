#! /bin/php
<?php

// File:	epm_run
// Author:	Robert L Walton <walton@acm.org>
// Date:	Sat Feb 22 11:40:11 EST 2020

$document = <<<'EOT'
EPM_HOME=root-directory \
EPM_DATA=data-directory \
EPM_UID=uid \
EPM_PROBLEM=problem \
EPM_DIR=working-subdirectory \
    epm_run [-d|-s] run-file [status-file]

Many parameters are environment variables so they will
not be listed when the command is listed.  The working-
subdirectory is relative to the data-directory.

The -d option performs a dry run that does not
execute any subprocesses or produce any scores.
The status-file is not used in this case.  The result
in the standard output just lists errors.  The exit
code is 0 for no errors, 1 if there are errors.  The
run-file may be in the current directory in this case.

Without -s, .in and .ftest files must be local, and
templates with NO CONDITION are used.

With -s, templates with the SUBMIT CONDITION are used,
the run-file must be remote, and the templates will
require that the .in, .ftest, generate_PPPP, and filter_
PPPP files be remote.

If there is a status-file, it is updated every few
tenths of a second with base name of the current input
file and the current execution times of the solution,
generate, and filter programs.  The status-file name
is relative to the current working directory of this
program.

A summary of the results is written to the standard
output.  Without the -d option, this includes the line:

	Run Score: XXXX

where XXXX is `Completely Correct' or something else.
If the Run Score is not `Completely Correct', the
output also includes the line:

	First Failed Test Case: YYYY

where YYYY is the basename for the test case.  The
test case files YYYY.in and YYYY.ftest may then be
symbolically linked to the local directory, if they
are not already there, but this program does not do
this.

But the individual .in file tests are done in the
EPM_WORK directory, which is treated the same as it is
when tests are run directly from the problems.php page
(but it may or may not be the same directory).

EOT;

if ( $argc < 2 || preg_match ( '/^-doc/', $argv[1] ) )
{
    echo $document;
    exit ( 0 );
}

$dryrun = false;
$submit = false;
$runfile = NULL;
$statfile = NULL;

while ( $argc >= 2
        &&
	preg_match ( '/^-(.)$/', $argv[1], $matches ) )
{
    if ( $matches[1] == 'd' )
        $dryrun = true;
    elseif ( $matches[1] == 's' )
        $submit = true;
    else
    {
        echo "epm_run: bad option {$argv[1]}\n";
	exit (1);
    }
    array_shift ( $argv );
    -- $argc;
}
if ( $argc < 2 || $argc > 3 )
{
    echo "epm_run: wrong number of arguments\n";
    exit (1);
}
$runfile = $argv[1];
if ( $argc == 3 ) $statfile = $argv[2];

// Note: $_ENV does NOT work here because $ is not in
// ini variables_order.  But getenv does work.
//
$epm_home = getenv ( 'EPM_HOME' );
$epm_data = getenv ( 'EPM_DATA' );
$uid      = getenv ( 'EPM_UID' );
$problem  = getenv ( 'EPM_PROBLEM' );
$dir      = getenv ( 'EPM_DIR' );

$probdir = "users/user$uid/$problem";
$include = "$epm_home/include";

include "$include/epm_make.php";

load_file_caches();

$rundata = $epm_data;
if ( $dryrun
     &&
     is_readable ( "$runfile" ) )
{
    $rundir = ".";
    $rundata = ".";
}
else if ( ! $submit
          &&
	  isset ( $local_file_cache[$runfile] ) )
    $rundir = $local_file_cache[$runfile];
else if ( $submit
          &&
	  isset ( $remote_file_cache[$runfile] ) )
    $rundir = $remote_file_cache[$runfile];
else
{
    echo "epm_run: cannot find $runfile" . PHP_EOL;
    exit ( 1 );
}

echo "Run-File: $runfile" . PHP_EOL;
$time = strftime ( "%FT%T%z" );
echo "Start-Time: $time" . PHP_EOL;

// Compute $runin as the list of lines of .run file.
//
$runin = @file_get_contents
		( "$rundata/$rundir/$runfile" );
if ( $runin === false )
{
    echo "epm_run: $rundir/$runfile is not readable" .
         PHP_EOL;
    exit ( 1 );
}

$runin = preg_replace ( '#(\R|^)\h*//.*#', '', $runin );
    // Get rid of `//...' comments.
$runin = explode ( "\n", $runin );
if ( array_slice ( $runin, -1, 1 ) == [""] )
    array_splice ( $runin, -1, 1 );

// Check that .in and .ftest files are locatable and
// readable.
//
if ( $submit )
{
    $cache = & $remote_file_cache;
    $cname = 'REMOTE';
}
else
{
    $cache = & $local_file_cache;
    $cname = 'LOCAL';
}

$errors = 0;
foreach ( $runin as $infile )
{
    if ( ! preg_match
               ( "/^([-_A-Za-z0-9]+)-$problem\\.in\$/",
	         $infile, $matches ) )
    {
        echo "epm_run: $infile is not acceptable .in" .
	     " file name" . PHP_EOL;
	if ( $errors >= 5 ) break;
	else continue;
    }
    $inbase = "{$matches[1]}-$problem";

    if ( ! isset ( $cache[$infile] ) )
    {
	echo "epm_run: cannot find $cname $infile" .
	     PHP_EOL;
	if ( ++ $errors >= 5 ) break;
	else continue;
    }
    $indir = $cache[$infile];
    if ( ! is_readable ( "$epm_data/$indir/$infile" ) )
    {
	echo "epm_run: cannot read $cname" .
	     " $indir/$infile" .  PHP_EOL;
	if ( ++ $errors >= 5 ) break;
	else continue;
    }
    $ftestfile = "$inbase.ftest";
    if ( ! isset ( $cache[$ftestfile] ) )
    {
	echo "epm_run: cannot find $cname $ftestfile" .
	     PHP_EOL;
	if ( ++ $errors >= 5 ) break;
	else continue;
    }
    $ftestdir = $cache[$ftestfile];
    if ( ! is_readable
               ( "$epm_data/$ftestdir/$ftestfile" ) )
    {
	echo "epm_run: cannot read $cname" .
	     " $ftestdir/$ftestfile" .  PHP_EOL;
	if ( ++ $errors >= 5 ) break;
	else continue;
    }
}
if ( $errors > 0 ) exit ( 1 );

if ( $dryrun ) exit ( 0 );

$desc = NULL;
if ( isset ( $statfile ) )
{
    $desc = fopen ( $statfile, 'w' );
    if ( $desc === false )
    {
	echo "epm_run: cannot open $statfile" .
	     " for writing" .  PHP_EOL;
	exit ( 1 );
    }
}

load_template_cache();

$warnings = [];
$errors   = [];
load_argument_map ( ! $submit, $warnings, $errors );

if ( count ( $errors ) > 0 )
{
    foreach ( $errors as $e )
	echo "epm_run: $e" .  PHP_EOL;
    exit ( 1 );
}

$lines = [];
foreach ( $runin as $base )
{
    start_make_file
	( "$base.in", "$base.score",
	   $submit ? 'SUBMIT': NULL,
	   true, "$probdir/+work+",
	   NULL, NULL /* no upload, upload_tmp */,
	   $warnings, $errors );
    if ( count ( $warnings ) > 0 )
    {
        echo "epm_run: WARNINGS during $base:" .
	     PHP_EOL;
	foreach ( $warnings as $w )
	    echo "    $w" . PHP_EOL;
    }
    if ( count ( $errors ) > 0 )
    {
        echo "epm_run: ERRORS during $base:" . PHP_EOL;
	foreach ( $errors as $e )
	    echo "    $e" . PHP_EOL;
	exit ( 1 );
    }
    $map = & $_SESSION['EPM_WORKMAP'];
    $lines[] = $base;
    $count = count ( $lines );
    if ( $count > 10 ) $count = 10;
    $r = NULL;
    while ( true )
    {
        $r = update_work_results();
	update_work_map();
	$line = $base;
	foreach ( $map as $key => $e )
	{
	    if ( $e[1] == 'X' ) continue;
	    preg_match ( '/\.(.+)stat$/', $e[0],
	                 $matches );
	    $line .= " {$matches[1]}:{$e[2]}s";
	}
	$lines[-1] = $line;
	if ( isset ( $statfile ) )
	{
	    $status = "";
	    for ( $i = 1; $i <= $count; $i += 1 )
		$status .= $lines[-$i] . PHP_EOL;
	    file_put_contents ( $statfile, $status );
	}
	if ( $r !== true ) break;
	usleep ( 500000 );
    }
    if ( $r === false )
    {
        echo "epm_run: $base died" . PHP_EOL;
	exit ( 1 );
    }
    elseif ( $r[0] == 'F' )
    {
        echo "epm_run: $base failed with exit code" .
	     " {$r[2]}:" . PHP_EOL .
	     "    {$r[3]}" . PHP_EOL;
	exit ( 1 );
    }
    echo $lines[-1] . PHP_EOL;
}

exit ( 0 );

?>
