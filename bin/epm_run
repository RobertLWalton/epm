#! /bin/php
<?php

// File:	epm_run
// Author:	Robert L Walton <walton@acm.org>
// Date:	Sat Mar  7 01:56:50 EST 2020

$document = <<<'EOT'
EPM_HOME=root-directory \
EPM_DATA=data-directory \
EPM_UID=uid \
EPM_PROBLEM=problem \
EPM_DIR=run-subdirectory \
    epm_run [-d|-s] run-file [work-dir [status-file]]

Many parameters are environment variables so they will
not be listed when the command is listed.  The working-
subdirectory is relative to the data-directory.

The -d option performs a dry run that does not
execute any subprocesses or produce any scores.
The status-file is not used in this case.  The result
in the standard output just lists errors.  The exit
code is 0 for no errors, 1 if there are errors.  The
run-file may be in the current directory in this case.

Without -s, .in and .ftest files must be local, and
templates with NO CONDITION are used.

With -s, templates with the SUBMIT CONDITION are used,
the run-file must be remote, and the templates will
require that the .in, .ftest, generate_PPPP, and filter_
PPPP files be remote.

If there is a status-file, it is updated every few
tenths of a second with base name of the current input
file and the current execution times of the solution,
generate, and filter programs.  The status-file name
is relative to the current working directory of this
program.

A summary of the results is written to the standard
output.  Without the -d option, this includes the line:

	Run Score: XXXX

where XXXX is `Completely Correct' or something else.
If the Run Score is not `Completely Correct', the
output also includes the line:

	First Failed Test Case: YYYY

where YYYY is the basename for the test case.  The
test case files YYYY.in and YYYY.ftest may then be
symbolically linked to the local directory, if they
are not already there, but this program does not do
this.

But the individual .in file tests are done in the
work-dir directory, which is treated the same as it is
when tests are run directly from the problems.php page
(but it may or may not be the same directory).

EOT;

if ( $argc < 2 || preg_match ( '/^-doc/', $argv[1] ) )
{
    echo $document;
    exit ( 0 );
}

function ERROR ( $message )
{
    echo 'epm_run: ' . $message . PHP_EOL;
    exit ( 1 );
}

function WARN ( $message )
{
    echo 'epm_run: warning: ' . $message . PHP_EOL;
}

$dryrun = false;
$submit = false;
$workdir = NULL;
$runfile = NULL;
$statfile = NULL;

while ( $argc >= 2
        &&
	preg_match ( '/^-(.)$/', $argv[1], $matches ) )
{
    if ( $matches[1] == 'd' )
        $dryrun = true;
    elseif ( $matches[1] == 's' )
        $submit = true;
    else
        ERROR ( "bad option {$argv[1]}" );
    array_shift ( $argv );
    -- $argc;
}
switch ( $argc )
{
    case 4:
	$statfile = $argv[3];
    case 3:
	$workdir = $argv[2];
    case 2:
	$runfile = $argv[1];
	break;
    default:
	ERROR ( "wrong number of arguments" );
}

// Note: $_ENV does NOT work here because $ is not in
// ini variables_order.  But getenv does work.
//
$epm_home = getenv ( 'EPM_HOME' );
$epm_data = getenv ( 'EPM_DATA' );
$uid      = getenv ( 'EPM_UID' );
$problem  = getenv ( 'EPM_PROBLEM' );
$dir      = getenv ( 'EPM_DIR' );

$probdir = "users/user$uid/$problem";
$include = "$epm_home/include";

include "$include/epm_make.php";

load_file_caches();

$rundata = $epm_data;
if ( $dryrun
     &&
     is_readable ( "$runfile" ) )
{
    $rundir = ".";
    $rundata = ".";
}
else if ( ! $submit
          &&
	  isset ( $local_file_cache[$runfile] ) )
    $rundir = $local_file_cache[$runfile];
else if ( $submit
          &&
	  isset ( $remote_file_cache[$runfile] ) )
    $rundir = $remote_file_cache[$runfile];
else
    ERROR ( "cannot find $runfile" );

// Compute $runin as the list of lines of .run file.
//
$runin = @file_get_contents
		( "$rundata/$rundir/$runfile" );
if ( $runin === false )
    ERROR ( "$rundir/$runfile is not readable" );

$runin = preg_replace ( '#(\R|^)\h*//.*#', '', $runin );
    // Get rid of `//...' comments.
$runin = explode ( "\n", $runin );
if ( array_slice ( $runin, -1, 1 ) == [""] )
    array_splice ( $runin, -1, 1 );

// Check that .in and .ftest files are locatable and
// readable.
//
if ( $submit )
{
    $cache = & $remote_file_cache;
    $cname = 'REMOTE';
}
else
{
    $cache = & $local_file_cache;
    $cname = 'LOCAL';
}

$errors = 0;
foreach ( $runin as $infile )
{
    if ( ! preg_match
               ( "/^([-_A-Za-z0-9]+)-$problem\\.in\$/",
	         $infile, $matches ) )
    {
        echo "epm_run: $infile is not acceptable .in" .
	     " file name" . PHP_EOL;
	if ( $errors >= 5 ) break;
	else continue;
    }
    $inbase = "{$matches[1]}-$problem";

    if ( ! isset ( $cache[$infile] ) )
    {
	echo "epm_run: cannot find $cname $infile" .
	     PHP_EOL;
	if ( ++ $errors >= 5 ) break;
	else continue;
    }
    $indir = $cache[$infile];
    if ( ! is_readable ( "$epm_data/$indir/$infile" ) )
    {
	echo "epm_run: cannot read $cname" .
	     " $indir/$infile" .  PHP_EOL;
	if ( ++ $errors >= 5 ) break;
	else continue;
    }
    $ftestfile = "$inbase.ftest";
    if ( ! isset ( $cache[$ftestfile] ) )
    {
	echo "epm_run: cannot find $cname $ftestfile" .
	     PHP_EOL;
	if ( ++ $errors >= 5 ) break;
	else continue;
    }
    $ftestdir = $cache[$ftestfile];
    if ( ! is_readable
               ( "$epm_data/$ftestdir/$ftestfile" ) )
    {
	echo "epm_run: cannot read $cname" .
	     " $ftestdir/$ftestfile" .  PHP_EOL;
	if ( ++ $errors >= 5 ) break;
	else continue;
    }
}
if ( $errors > 0 ) exit ( 1 );

if ( $dryrun ) exit ( 0 );

load_template_cache();

$warnings = [];
$errors   = [];
load_argument_map ( ! $submit, $warnings, $errors );

if ( count ( $errors ) > 0 )
{
    foreach ( $errors as $e )
	echo "epm_run: $e" .  PHP_EOL;
    exit ( 1 );
}

echo "Run-File: $runfile" . PHP_EOL;
$start_time = microtime ( true );
echo "Start-Time: " .
     strftime ( "%FT%T%z", $start_time ) .  PHP_EOL;

$lines = [];
$max_map = ['g' => 0, 's' => 0, 'f' => 0];
$first_failed = NULL;
$score = NULL;
$warnings_count = 0;
foreach ( $runin as $infile )
{
    $base = pathinfo ( $infile, PATHINFO_FILENAME );
    start_make_file
	( "$base.in", "$base.score",
	   $submit ? 'SUBMIT': NULL,
	   true, $workdir,
	   NULL, NULL /* no upload, upload_tmp */,
	   $warnings, $errors );
    if ( count ( $warnings ) > 0 )
    {
        echo "epm_run: WARNINGS during $base:" .
	     PHP_EOL;
	foreach ( $warnings as $w )
	{
	    echo "    $w" . PHP_EOL;
	    $warnings_count += 1;
	}
    }
    if ( count ( $errors ) > 0 )
    {
	$first_failed = $base;
	$score = 'EPM System Error';
	break;
    }
    $map = & $_SESSION['EPM_WORK']['MAP'];
    $lines[] = $base;
    $count = count ( $lines );
    if ( $count > 10 ) $count = 10;
    $r = NULL;
    while ( true )
    {
        $r = update_work_results();
	update_workmap();
	$line = $base;
	foreach ( $map as $key => $e )
	{
	    if ( $e[1] == 'X' ) continue;
	    preg_match ( '/\.(.+)stat$/', $e[0],
	                 $matches );
	    $line .= " {$matches[1]}:{$e[2]}s";
	}
	$lines[-1] = $line;
	if ( isset ( $statfile ) )
	{
	    $status = "";
	    for ( $i = 1; $i <= $count; $i += 1 )
		$status .= $lines[-$i] . PHP_EOL;
	    file_put_contents ( $statfile, $status );
	}
	if ( $r !== true ) break;
	usleep ( 500000 );
    }

    echo $lines[-1] . PHP_EOL;
    foreach ( $map as $key => $e )
    {
	if ( $e[1] == 'X' ) continue;
	preg_match ( '/\.(.).*stat$/', $e[0],
		     $matches );
        $t = $matches[1];
	if ( $max_map[$t] < $e[2] )
	    $max_map[$t] = $e[2];
    }

    if ( $r === false )
    {
        $errors[] = "$base died";
	$first_failed = $base;
	$score = 'Program Crashed';
	break;
    }
    elseif ( $r != ['D',0] )
    {
        $score = get_exit_message ( $r[1] );
        $errors[] = "$base failed with exit code"
	          . " {$r[1]}:" . PHP_EOL
	          . "      $score";
	$first_failed = $base;
	break;
    }

    $f = "$workdir/$base.score";
    $score = @file_get_contents ( "$epm_data/$f" );
    if ( $score === false )
    {
        $errors[] = "cannot read $f";
	$first_failed = $base;
	$score = 'EPM System Error';
	break;
    }
    if ( trim ( $score ) != 'Completely Correct' )
    {
        $score = explode ( "\n", $score );
	$score = trim ( $score[0] );
        $errors[] = "$base: $score";
	$first_failed = $base;
	break;
    }
}
if ( count ( $errors ) > 0 )
{
    echo "Errors While Processing $first_failed" .
         PHP_EOL;
    foreach ( $errors as $e )
        echo "    $e" . PHP_EOL;
    echo "First-Failed-Test-Case: $first_failed" .
         PHP_EOL;
    echo "Score: $score" . PHP_EOL;
}
else
    echo "Score: Completely Correct" . PHP_EOL;

if ( $warnings_count > 0 )
    echo "Number-of-Warning-Messages:" .
         " $warnings_count" . PHP_EOL;

$max_label = ['g' => 'Generate', 's' => 'Solution',
              'f' => 'Filter'];
foreach ( $max_map as $key => $value )
    echo "Maximum-{$max_label[$key]}-Time: {$value}s" .
         PHP_EOL;

$duration = microtime ( true ) - $start_time;
echo "Run-Real-Time: " . sprintf ( '%.3f', $duration ) .
     "s" . PHP_EOL;

exit ( 0 );

?>
