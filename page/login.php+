<?php

    // File:	login.php
    // Author:	Robert L Walton <walton@acm.org>
    // Date:	Sat Jan  4 05:09:53 EST 2020

    // Handles login for a session.
    //
    // Data:
    //
    //    BDIR	    Browser data directory:
    //                $epm_data/admin/browser
    //
    //    EDIR	    Email data directory:
    //                $epm_data/admin/email
    //
    //    EMAIL	    User email address.  Used as the
    //              user name.
    //
    //    UID	    User ID.  A non-zero natural number.
    //		    Stored in EDIR/EMAIL if that file
    //              exists, which it does unless the
    //		    user is a new user, in which case
    //              UID does not exist during login.
    //
    //    BID	    Browser ID.  A 32-hex-digit random
    //		    number generated by the server to
    //		    identify the browser, and stored
    //		    in the browser local memory.
    //
    //    KEYA	    Two encryption Keys.  32-hex-digit
    //	  KEYB      random numbers generated by the
    //		    server for use in a handshake
    //		    protocol that certifies browser
    //		    identity.  Stored in browser local
    //		    memory.
    //
    //	  CNUM	    Confirmation Number.  32-hex-digit
    //		    random number generated by the
    //		    server and emailed to the user, who
    //		    enters it into the browser during
    //		    the protocol that creates the
    //		    broswer local memory ITEM.  Only
    //		    exists if browser identification
    //		    protocol is MANUAL, and not AUTO.
    //
    //     LTIME    Login Time.  Time server receives
    //		    first browser identification
    // 		    protocal POST.  Stored in
    //              '%FT%T%z' (ISO 8601) format.
    //
    //     CTIME    Confirmation Time.  LTIME for the
    //		    last time browser was confirmed.
    //
    //     BID-FILE The file BDIR/BID that contains just
    //		    the line:
    //
    //			EMAIL KEYA KEYB CTIME
    //
    //		    File is written by server when it
    //		    successfully completes the MANUAL
    //		    browser identification protocol that
    //		    uses a confirmation number (CNUM).
    //
    //	   ITEM     Browser Local Memory Item, stored
    //		    using EMAIL as the item key when
    //		    the browser is notified that the
    //              MANUAL browser id protocol has been
    //              successfully completed.  Just the
    //              single line:
    //
    //			BID KEYA KEYB CTIME
    //
    //		    in the browser local memory.
    //
    //      FTIME   LTIME of first time user was
    //              confirmed.
    //
    //      CCOUNT  Number of times user has been
    //              confirmed.
    //
    //   EMAIL-FILE The file EDIR/EMAIL (where here only
    //		    EMAIL is encoded by rawurlencode)
    //              that contains just the line:
    //
    //			USER_ID FTIME CCOUNT
    //
    //		    File is initialized by user_edit.php
    //		    when user first logs in, after
    //		    confirmation.  CCOUNT is updated
    //		    by this page on subsequent confirma-
    //              tions.
    //
    // When the browser identification protocol
    // successfully complete, the server sets the
    // the following values in $_SESSION:
    //
    //    EPM_EMAIL => EMAIL
    //    EPM_BROWSER_ID => BID
    //    EPM_LOGIN_TIME => LTIME
    //    EPM_USER_ID => UID, but not set for new user.
    //
    // Next page is page/problem_select.php if user is
    // NOT new and page/user_edit.php otherwise.  In
    // the case of a new user, this last page determines
    // UID and sets EPM_USER_ID.
    //
    // During the execution of the browser identifica-
    // tion protocol, $_SESSION['EPM_BROWSER_DATA']
    // is used to hold BID, EMAIL, LTIME, CTIME, KEYA,
    // KEYB, CNUM, UID, FTIME, and CCOUNT.  During the
    // protocal the browser stores BID, EMAIL, CTIME,
    // KEYA, KEYB, and CNUM in var's of the same name.
    //
    // Each execution of the browser identification
    // protocol is logged separately to the file:
    //
    //		admin/login.log
    //
    // if that file exists and is writeable. The file
    // format is
    //
    //	 // comment
    //   BID EMAIL UID IPADDR LTIME CTIME FTIME CCOUNT
    //
    // where IPADDR is $_SESSION['EPM_IPADDR'] and for
    // a new user UID is 'NEW', CTIME and FTIME equals
    // LTIME, and CCOUNT is 0.


    // Browser Identification Protocol
    // -------------------------------
    //
    // The browser runs the protocol using javascript
    // XMLHttpRequest to POST requests.  When the
    // browser is notified of success, it is given
    // a page to go to (page/problem_select.php or
    // for new users page/user_edit.php).
    //
    // The protocol is:
    //
    // BEGIN:
    //	   * AUTO_RETRY = 0
    //     * Get EMAIL from user.
    //	   * Get ITEM = localStorage.getItem(EMAIL)
    //	   * If ITEM != null:
    //		* Parse ITEM to get BID, KEYA, KEYB
    //          * MANUAL = no
    //          * go to AUTO_ID
    // MANUAL_ID:
    //	   * MANUAL = yes
    //     * Send 'op=MANUAL&value=EMAIL'
    //     * Receive one of:
    //           'BAD_EMAIL': FAIL
    //           'NEW BID EKEYA EKEYB CTIME' where
    //                    EKEYA, EKEYB are KEYA, KEYB
    //                    encrypted using CNUM.
    // EXPIRED:
    //     * Get CNUM from user.
    //     * Decrypt EKEYA and EKEYB using CNUM to get
    //	     KEYA, KEYB.
    // AUTO_ID:
    //     * AUTO_RETRY += 1
    //     * If AUTO_RETRY > 2: FAIL
    //     * Send 'op=AUTO&value=BID'
    //	   * Receive one of:
    //           'EXPIRED BID EKEYA EKEYB CTIME':
    //               go to EXPIRED
    //           'FAILED':  (means BID not recognized)
    //               go to AUTO_ID
    //		 'SHAKE HANDSHAKE':
    //               continue with following
    //     * Decrypt HANDSHAKE using KEYA and encrypt
    //       result using KEYB to get SHAKEHAND.
    //     * Send 'op=SHAKE&value=SHAKEHAND'
    //     * Receive one of:
    //           'FAILED':
    //               go to AUTO_ID
    //           'DONE NEXT_PAGE':
    //               continue with following
    //     * If MANUAL:
    //		* ITEM = 'BID KEYA KEYB CTIME'
    //          * localStorage.setItem(EMAIL,ITEM)
    //     * Issue GET to NEXT_PAGE
    //
    // The server generates bid, keyA, keyB, confirma-
    // tion number and handshake as 128-bit binary
    // strings.  Encrypted values are binary strings.
    // Binary strings are transmitted as hexadecimal
    // strings.  Ctime is the time that the browser was
    // last confirmed, or the time the server receives
    // the MANUAL post, and is in '%FT%T%z' (ISO 8601)
    // format.  The browser does not use it in the
    // protocol.
    //
    // Encryption is by AES-128-CRC with zero initial
    // vector.  All encrypted items are 128 bit random
    // numbers.
    //
    // Multiple invocations of MANUAL for the same
    // session with the same EMAIL will use the same
    // cnumber, so as not to confuse the user.

    require "{$_SERVER['DOCUMENT_ROOT']}/index.php";
    umask ( 07 );

    // require "$include/debug_info.php";


    $op = NULL;
    if ( isset ( $_POST['op'] ) )
        $op = $_POST['op'];

    // Process POSTs from xhttp.
    //
    if ( $op == 'MANUAL_ID' )
    {
	$email = trim ( $_POST['email'] );
	$e = filter_var
	    ( $email, FILTER_SANITIZE_EMAIL );

	if ( $e != $email
	     ||
	     ! filter_var
		      ( $email,
			FILTER_VALIDATE_EMAIL ) )
	{
	    echo ( 'BAD_EMAIL' );
	    exit;
	}

	if ( ! isset ( $_SESSION['EPM_BROWSER_DATA'] ) )
	    $_SESSION['EPM_BROWSER_DATA'] = [];
	$data = & $_SESSION['EPM_BROWSER_DATA'];

	$efile = "$epm_data/admin/email/"
	       . rawurlencode ( $email );
	if ( is_readable ( $efile ) )
	{
	    $c = file_get_contents ( $efile );
	    if ( $c !== false )
	        ERROR ( "failed to read readable" .
		        " file $efile" );
	    $c = trim ( $c );
	    $item = explode ( ' ', $c );
	    if ( count ( $item ) != 3 )
	        ERROR ( "$efile value '$e' badly" .
		        " formatted" );
	    $data['UID'] = $item[0];
	    $data['FTIME'] = $item[1];
	    $data['CCOUNT'] = $item[2];
	}

	if ( ! isset ( $data['EMAIL'] )
	     ||
	     $data['EMAIL'] != $email )
	{
	    $data['EMAIL'] = $email;
	    $data['CNUM'] =
		bin2hex ( random_bytes ( 16 ) );
	}
	$data['KEYA'] = bin2hex ( random_bytes ( 16 ) );
	$data['KEYB'] = bin2hex ( random_bytes ( 16 ) );
	$data['CTIME'] = $_SESSION['EPM_SESSION_TIME'];

	mail ( $email, "Your Confirmation Number",
	       "Your confirmation number is:\r\n" .
	       "\r\n" .
	       "     {$data['CNUM'}\r\n",
	       ["From" =>
	        "no_reply@{$_SERVER['SERVER_NAME']}"] );

	$iv = hex2bin
	    ( "00000000000000000000000000000000" );
	$ekeyA = bin2hex ( openssl_encrypt
	    ( hex2bin ( $data['KEYA'] ), "aes-128-cbc",
	      hex2bin ( $data['CNUM'] ),
	      OPENSSL_RAW_DATA, $iv ) );
	$ekeyB = bin2hex ( openssl_encrypt
	    ( hex2bin ( $data['KEYB'] ), "aes-128-cbc",
	      hex2bin ( $data['CNUM'] ),
	      OPENSSL_RAW_DATA, $iv ) );
					e
	echo ( "NEW {$data['BID'} $ekeyA $ekeyB" .
	       " {$data['CTIME']}" );
	exit;
    }
    elseif ( $op == 'AUTO_ID' )
    {
    }
    elseif ( $op == 'SHAKE' )
    {
    }
    // Else load login.php.


TBD

    // Data set by GET and POST requests.
    //
    $email = NULL;
        // User must be asked for an email address iff
	// this remains NULL.
    if ( isset ( $_SESSION['epm_email'] ) )
        $email = $_SESSION['epm_email'];
    $bad_email = NULL;
        // If this becomes non-NULL, it is a user given
	// email address that is rejected.
    $confirmation_time = NULL;
        // User must be asked for confirmation number,
	// or must be auto-confirmed, if this remains
	// NULL and email is not NULL.  This must be
	// NULL if email is NULL.
    if ( isset ( $_SESSION['epm_confirmation_time'] ) )
        $confirmation_time =
	    $_SESSION['epm_confirmation_time'];
    $bad_confirm = false;
        // If this becomes true, confirmation number
	// given by the user was invalid, and new number
	// must be asked for.
    $userid = NULL;
        // This is set when userid is found using email
	// address.  For new users, it is never set
	// (it will be set by user_edit.php).
	// This must be NULL if $email is NULL.
	//
	// NOTE: setting this does NOT set $_SESSION
	// ['epm_userid'], which is not set until
	// after confirmation.
    if ( isset ( $_SESSION['epm_userid'] ) )
        $userid = $_SESSION['epm_userid'];
    $user_admin = NULL;
        // User admin parameters if they exist.
	// Is NULL if $userid is NULL.

    // Set userid and $user_admin according to $email.
    // Does nothing for new user.  
    //
    function set_userid()
    {
        global $email, $epm_data, $userid, $user_admin,
	       $include;

	$f = "admin/email_index/$email";
	if ( is_readable ( "$epm_data/$f" ) )
	{
	    $u = file_get_contents ( "$epm_data/$f" );
	    $u = trim ( $u );
	        // In case $f was edited by hand and a
		// \n was introduced.
	    if ( ! preg_match
		      ( '/^[1-9][0-9]*$/', $u ) )
	    {
		$sysfail = "$f has value $u";
		require "$include/sysalert.php";
	    }
	    $userid = $u;
	    $f = "admin/user{$userid}.info";
	    if ( is_readable ( "$epm_data/$f" ) )
		$user_admin =
		    get_json ( $epm_data, $f );
	}
    }

    // Log confirmation attempt or auto-confirmation.
    //
    function log_confirmation()
    {
    	global $confirmation_time, $email, $epm_data,
	       $include;

	$date_format = "%FT%T%z";

	$f = "admin/login.log";
	if ( is_writable ( "$epm_data/$f" ) )
	{
	    $desc = fopen ( "$epm_data/$f", 'a' );
	    if ( $desc === false )
	    {
		$sysfail =
		    "cannot append to writable $f";
		require "$include/sysalert.php";
	    }
	    $ipaddr = $_SESSION['epm_ipaddr'];
	    $log_login_time =
		strftime ( $date_format,
			   $_SESSION
			     ['epm_login_time'] );
	    if ( isset ( $confirmation_time ) )
		$log_confirmation_time = strftime
		    ( $date_format,
		      $confirmation_time );
	    else
		$log_confirmation_time = 'FAILED';
	    fputcsv
		( $desc,
		  [ $email,
		    $ipaddr,
		    $log_login_time,
		    $log_confirmation_time ] );
	    fclose ( $desc );
	}
    }

    if ( $method == 'GET' )
    {
        // Users is trying to initiate or continue
	// login.
	//
	if ( isset ( $userid ) )
	{
	    header ( "Location: problem.php" );
	    exit;
	}
	elseif ( isset ( $confirmation_time ) )
	{
	    header ( "Location: user_edit.php" );
	    exit;
	}
	// else fall through to continue login.
    }

    elseif ( $method != 'POST' )
        exit ( 'UNACCEPTABLE HTTP METHOD ' . $method );

    elseif ( isset ( $confirmation_time ) )
        exit ( 'UNACCEPTABLE HTTP POST' );

    elseif ( isset ( $userid ) )
        exit ( 'UNACCEPTABLE HTTP POST' );

    elseif ( isset ( $_POST['email'] ) )
    {
	// User answer to request for email address.
	// May be request to change email.

	$new_email = trim ( $_POST['email'] );
	$e = filter_var
	    ( $new_email, FILTER_SANITIZE_EMAIL );

	if ( $new_email == "" ) /* Do nothing */;
	    // "" sent by by user typing just
	    // carriage return.
	else if ( $e != $new_email )
	    $bad_email = $new_email;
	else if ( ! filter_var
		      ( $new_email,
			FILTER_VALIDATE_EMAIL ) )
	    $bad_email = $new_email;
	else
	{
	    $email = $e;
	    $_SESSION['epm_email'] = $email;
	    $userid = NULL;
	    $user_admin = NULL;
	    set_userid();
	}
    }
    else if ( isset ( $_POST['confirm_tag'] ) )
    {
	if ( ! isset ( $email ) )
	    exit ( 'UNACCEPTABLE HTTP POST' );
	elseif (    $_SESSION['confirm_tag']
		  == $_POST['confirm_tag'] )
	{
	    $confirmation_time = time();
	    $_SESSION['epm_confirmation_time'] =
		$confirmation_time;
	}
	else
	    $bad_confirm = true;

	log_confirmation();
    }

    if (    isset ( $confirmation_time )
         && isset ( $user_admin ) )
    {
        // Record current time as last confirmation
	// time for the user and ip address.
	//
	$ipaddr = $_SESSION['epm_ipaddr'];
	$user_admin['confirmation_time'][$ipaddr] =
	    strftime ( '%FT%T%z', $confirmation_time );
	$j = json_encode
	    ( $user_admin, JSON_PRETTY_PRINT );
	$f = "admin/user{$userid}.info";
	$r = file_put_contents ( "$epm_data/$f", $j );
	if ( $r === false )
	{
	    $sysfail = "cannot write $f";
	    require "$include/sysalert.php";
	}
    }

    // This must be done after recording confirmation_
    // time as it may set $confirmation_time to an old
    // value.
    //
    if (    ! isset ( $confirmation_time )
         && isset ( $user_admin ) )
    {
	// Check if we can auto-confirm for this
	// user and ip address.
	//
	$ipaddr = $_SESSION['epm_ipaddr'];
	if ( isset ( $user_admin['confirmation_time']
	                        [$ipaddr] ) )
	{
	    $ctime = strtotime
		( $user_admin['confirmation_time']
		             [$ipaddr] );
	    if (   time()
	         < $ctime + $confirmation_interval )
	    {
	        $confirmation_time = $ctime;
		$_SESSION['epm_confirmation_time'] =
		    $confirmation_time;
		log_confirmation();
	    }
	}
    }

    if ( isset ( $confirmation_time ) )
    {
	if ( ! isset ( $userid ) )
	    header ( "Location: user_edit.php" );
	else
	{
	    if ( isset ( $userid ) )
	        $_SESSION['epm_userid'] = $userid;
	    header ( "Location: problem.php" );
	}
	exit;
    }
    else if ( isset ( $email ) )
	$_SESSION['confirm_tag'] =
	    bin2hex ( random_bytes ( 8 ) );

?>

<html>

<body>
<!-- body elements must be BEFORE script so that
     getElementById can be used to set global vars -->

<div id='get_email' style.display='none'>
<input type='text' id='email_in'
       placeholder='Enter Email Address'>
</div>

<div id='show_email' style.display='none'>
Email:&nbsp;<span id='email_out'></span>
<button onclick="window.location.reload(true)">
Retry Login from Beginning
</button>
<br>
<button onclick="RESET_EMAIL()">
Re-confirm above email address.
</button>
<br>
<button onclick="RESET_BROWSER()">
Reset Browser
</button><br>
(You will have reconfirm all email addresses used with this browser.)
</div>

<div id='get_cnum' style.display='none'>
A Confirmation Number has been sent to the above Email Address.
<br>
Please <input type='text' id='cnum_in'
       placeholder='Enter Confirmation Number'>
</div>

<script>

var LOG = function(message) {};  // Disable logging.
var LOG = console.log;           // Enable logging.

var xhttp = new XMLHttpRequest();
var storage = window.localStorage;
var get_email = document.getElementById("get_email")'
var show_email = document.getElementById("show_email")'
var get_cnum = document.getElementById("get_cnum")'

function FAIL ( message )
{
    // Alert must be scheduled as separate task.
    //
    setTimeout ( function () {
	alert ( message );
	window.location.reload ( true );
    });
}

function RESET_EMAIL()
{
    storage.removeItem ( EMAIL );
    window.location.reload ( true );
}

function RESET_BROWSER()
{
    storage.clear();
    window.location.reload ( true );
}

function ALERT ( message )
{
    // Alert must be scheduled as separate task.
    //
    setTimeout ( function () { alert ( message ); } );
}

var REQUUEST_IN_PROGRESS = false;
function SEND ( data, callback, error_message )
{
    xhttp.onreadystatechange = function() {
	LOG ( 'xhttp state changed to '
	      + this.readyState );
	if ( this.readyState !== XMLHttpRequest.DONE )
	    return;

	if ( this.status != 200 )
	    FAIL ( 'Bad response status (' + this.status
	           + ') from server on '
	           + error_message );
	else if ( REQUEST_IN_PROGRESS )
	{
	    REQUEST_IN_PROGRESS = false;
	    LOG ( 'xhttp response: '
	          + this.responseText );
	    callback ( this.responseText )
	}
    };
    xhttp.open ( 'POST', "login.php", true );
    xhttp.setRequestHeader
        ( "Content-Type",
	  "application/x-www-form-urlencoded" );
    REQUEST_IN_PROGRESS = true;
    LOG ( 'xhttp sent: ' + data );
    xhttp.send ( data );
}

var IMPORTKEY, ENCRYPT, DECRYPT;
var IV = new Uint8Array ( 16 );
    // 16 zero bytes.

if ( window.msCrypto !== undefined )
{

    IMPORTKEY = function ( key, callback )
    {
	window.msCrypto.subtle.importKey
	    ( "raw", hex2ArrayBuffer ( key ),
	      "AES-CBC", true, ["encrypt", "decrypt"] )
	    .oncomplete
	        ( function(r)
		  { callback ( r.target.result ) } )
	    .onerror
	        ( function(r)
		  { callback
		      ( new Error
		          ( 'key import failed' ) ) } );
    }

    ENCRYPT = function ( cryptokey, data, callback )
    {
	window.msCrypto.subtle.encrypt
	    ( { name: "AES-CBC", iv }, cryptokey,
	      hex2ArrayBuffer ( data ) )
	    .oncomplete
	        ( function(r)
		  { callback
		      ( ArrayBuffer2hex
		          ( r.target.result ) ) } )
	    .onerror
	        ( function(r)
		  { callback
		      ( new Error
		          ( 'encryption failed' ) ) } );
    }

    DECRYPT = function ( cryptokey, data, callback )
    {
	window.msCrypto.subtle.decrypt
	    ( { name: "AES-CBC", iv }, cryptokey,
	      hex2ArrayBuffer ( data ) )
	    .oncomplete
	        ( function(r)
		  { callback
		      ( ArrayBuffer2hex
		          ( r.target.result ) ) } )
	    .onerror
	        ( function(r)
		  { callback
		      ( new Error
		          ( 'decryption failed' ) ) } );
    }

} else {

    IMPORTKEY = function ( key, callback )
    {
	window.crypto.subtle.importKey
	    ( "raw", hex2ArrayBuffer ( key ),
	      "AES-CBC", true, ["encrypt", "decrypt"] )
	    .then ( callback )
	    .catch
	        ( function(r)
		  { callback
		      ( new Error
		          ( 'key import failed' ) ) } );
    }

    ENCRYPT = function ( cryptokey, data, callback )
    {
	window.crypto.subtle.encrypt
	    ( { name: "AES-CBC", iv }, cryptokey,
	      hex2ArrayBuffer ( data ) )
	    .then
	        ( function(r)
		  { callback
		      ( ArrayBuffer2hex ( r ) ) } )
	    .catch
	        ( function(r)
		  { callback
		      ( new Error
		          ( 'encryption failed' ) ) } );
    }

    DECRYPT = function ( cryptokey, data, callback )
    {
	window.crypto.subtle.decrypt
	    ( { name: "AES-CBC", iv }, cryptokey,
	      hex2ArrayBuffer ( data ) )
	    .then
	        ( function(r)
		  { callback
		      ( ArrayBuffer2hex ( r ) ) } )
	    .catch
	        ( function(r)
		  { callback
		      ( new Error
		          ( 'decryption failed' ) ) } );
    }

}
    
var AUTO_RETRY, EMAIL, ITEM, BID, KEYA, KEYB, CTIME,
    MANUAL, CNUM, CRYPTOKEY, HANDSHAKE, SHAKEHAND;

// BEGIN:
//
AUTO_RETRY = 0;
EMAIL = null;
ITEM = null;
show_email.style.display = 'none';
GET_EMAIL_ENABLED = true;
get_email.style.display = 'block';

var GET_EMAIL_ENABLED = false;
function EMAIL_KEYDOWN ( event )
{
    if ( event.code == 'Enter'
         &&
	 GET_EMAIL_ENABLED )
    {
	var value = email.value.trim();
	if ( /^\S+@\S+\.\S+$/.test(value) )
	{
	    GET_EMAIL_ENABLED = false;
	    GOT_EMAIL ( value );
	}
	else if ( value != '' )
	    ALERT ( value + " is not a valid" +
	            " email address" );
    }
}
email_in.addEventListener ( 'keydown', EMAIL_KEYDOWN );

function GOT_EMAIL ( email )
{
    EMAIL = email;
    get_email.style.display = 'none';
    email_out.innerHTML = EMAIL;
    show_email.style.display = 'block';
    ITEM = storage.getItem(EMAIL);
    if ( item == null )
        MANUAL_ID();
    else
    {
        var ITEMlist = ITEM.split ( ' ' );
	BID = ITEMlist[0];
	KEYA = ITEMlist[1];
	KEYB = ITEMlist[2];
	MANUAL = false;
	AUTO_ID();
    }
}

function MANUAL_ID()
{
    MANUAL = true;
    SEND ( "op=MANUAL&value="
           + encodeURIComponent ( EMAIL ),
           MANUAL_RESPONSE,
	   'sending ' + EMAIL + ' to server' );
}

function MANUAL_RESPONSE ( response )
{
    var r = response.split ( ' ' );
    if ( r[0] == 'NOT_EMAIL' )
        FAIL ( EMAIL +
	       ' is not a valid email address' );
    else if ( r[0] != 'NEW'
	      ||
	      r.length != 5 )
        FAIL ( 'Response from server on sending '
	       + EMAIL + ' to server is malformed' );
    else
    {
	BID = r[1];
	EKEYA = r[2];
	EKEYB = r[3];
	CTIME = r[4];
	EXPIRED();
    }
};

function EXPIRED()
{
    GET_CNUM_ENABLED = true;
    get_cnum.style.display = 'block';
}

var GET_CNUM_ENABLED = false;
function CNUM_KEYDOWN ( event )
{
    if ( event.code == 'Enter'
         &&
	 GET_CNUM_ENABLED )
    {
	value = cnum.value.trim();
	if ( /^[a-f0-9]{32}$/.test(value) )
	{
	    GET_CNUM_ENABLED = false;
	    GOT_CNUM ( value );
	}
	else if ( value != '' )
	    ALERT ( value + ' is not a valid' +
	            ' confirmation number' )';
    }
}
cnum_in.addEventListener ( 'keydown', CNUM_KEYDOWN );

function GOT_CNUM ( cnum )
{
    CNUM = cnum;
    IMPORTKEY ( cnum, GOT_CNUM_KEY );
}

function CNUM_NOT_VALID()
{
    alert ( CNUM + ' is not valid;'
	    + ' try again or reset' );
    EXPIRED();
}

function GOT_CNUM_KEY ( cryptokey )
{
    if ( cryptokey instanceof Error )
    {
        CNUM_NOT_VALID();
	return;
    }
    CRYPTOKEY = cryptokey;
    DECRYPT ( EKEYA, CRYPTOKEY, GOT_KEYA );
}

function GOT_KEYA ( keyA )
{
    if ( keyA instanceof Error )
    {
        CNUM_NOT_VALID();
	return;
    }
    KEYA = keyA;
    DECRYPT ( EKEYB, CRYPTOKEY, GOT_KEYB );
}

function GOT_KEYB ( keyB )
{
    if ( keyB instanceof Error )
    {
        CNUM_NOT_VALID();
	return;
    }
    KEYB = keyB;
    AUTO_ID();
}

function AUTO_ID()
{
    AUTO_RETRY += 1
    if ( AUTO_RETRY > 2 )
        FAIL ( 'two attempts at handshake failed' );
    SEND ( 'op=AUTO&value=' + BID,
           AUTO_RESPONSE,
	   'starting handshake with server' );
}

function AUTO_RESPONSE ( item )
{
    item = item.split ( ' ' );
    if ( item[0] == 'EXPIRED' )
    {
	storage.removeItem ( EMAIL );
        if ( item.length != 5 )
	    FAIL ( 'bad response from server during'
	           + ' handshake; re-confirmation'
		   + ' required' );
	BID   = item[1];
	EKEYA = item[2];
	EKEYB = item[3];
	CTIME = item[4];
	EXPIRED();
	return;
    }
    else if ( item[0] == 'FAIL' )
    {
	storage.removeItem ( EMAIL );
	FAIL ( 'browser/email not known to server;'
	       + ' re-confirmation required' );
    }
    else if ( item[0] == 'SHAKE' )
    {
        HANDSHAKE = item[1];
	IMPORTKEY ( KEYA, GOT_KEYA );
    }
    else
        FAIL ( 'Response from server on sending'
	       + 'browser ID to server is malformed' );
}

function GOT_KEYA ( cryptokey )
{
    if ( cryptokey instanceof Error )
    {
        AUTO_ID();  // Retry
	return;
    }
    DECRYPT ( HANDSHAKE, cryptokey, GOT_SHAKEA );
}

function GOT_SHAKEA ( shakeA )
{
    if ( cryptokey instanceof Error )
    {
        AUTO_ID();  // Retry
	return;
    }
    SHAKEHAND = shakeA;
    IMPORTKEY ( KEYB, GOT_KEYB );
}

function GOT_KEYB ( cryptokey )
{
    if ( cryptokey instanceof Error )
    {
        AUTO_ID();  // Retry
	return;
    }
    ENCRYPT ( SHAKEHAND, cryptokey, GOT_SHAKEB );
}

function GOT_SHAKEB ( shakeB )
{
    if ( cryptokey instanceof Error )
    {
        AUTO_ID();  // Retry
	return;
    }
    SHAKEHAND = shakeB;
    SEND ( 'op=HAND&value=' + SHAKEHAND,
           SHAKE_RESPONSE,
	   'sending handshake to server' );
}

function SHAKE_RESPONSE ( item )
{
    item = item.split ( ' ' );
    if ( item[0] == 'FAILED' )
    {
        AUTO_ID();  // Retry
	return;
    }
    else if ( item[0] == 'DONE'
              &&
	      item.length == 2 )
    {
        if ( MANUAL )
	    storage.storeITEM
	        ( EMAIL,
		  BID + ' '
		  KEYA + ' '
		  KEYB + ' '
		  CTIME );
	try {
	    window.location.assign ( item[2] );
	} catch ( e ) {
	    FAIL
	       ( 'could not access page ' + item[2] );
	       // On retry login.php will go to
	       // correct page.
    }
    else
        FAIL ( 'Response from server on sending'
	       + 'browser ID to server is malformed' );
}
    
</script>


</body>
</html>
