<?php

    // File:	login.php
    // Author:	Robert L Walton <walton@acm.org>
    // Date:	Sun Jan  5 07:18:49 EST 2020

    // Handles login for a session.
    //
    // Data:
    //
    //    BDIR	    Browser data directory:
    //                $epm_data/admin/browser
    //
    //    EDIR	    Email data directory:
    //                $epm_data/admin/email
    //
    //    EMAIL	    User email address.  Used as the
    //              user name.
    //
    //    UID	    User ID.  A non-zero natural number.
    //		    Stored in EDIR/EMAIL if that file
    //              exists, which it does unless the
    //		    user is a new user, in which case
    //              UID does not exist during login.
    //
    //    BID	    Browser ID.  A 32-hex-digit random
    //		    number generated by the server to
    //		    identify the browser, and stored
    //		    in the browser local memory.
    //
    //    KEYA	    Two encryption Keys.  32-hex-digit
    //	  KEYB      random numbers generated by the
    //		    server for use in a handshake
    //		    protocol that certifies browser
    //		    identity.  Stored in browser local
    //		    memory.
    //
    //	  CNUM	    Confirmation Number.  32-hex-digit
    //		    random number generated by the
    //		    server and emailed to the user, who
    //		    enters it into the browser during
    //		    the protocol that creates the
    //		    broswer local memory TICKET.  Only
    //		    exists if browser identification
    //		    protocol is MANUAL, and not AUTO.
    //
    //     STIME    Session Time.  The time of the
    //		    request that created the current
    //		    session, as stored in $_SESSION
    //		    ['EPM_SESSION_TIME'] in '%FT%T%z'
    //		    (ISO 8601) format.
    //
    //     CTIME    Confirmation Time.  STIME for the
    //		    session that last confirmed the
    //		    browser.
    //
    //     BID-FILE The file BDIR/BID that contains just
    //		    the line:
    //
    //			EMAIL KEYA KEYB CTIME
    //
    //		    File is written by server when it
    //		    successfully completes the MANUAL
    //		    browser identification protocol that
    //		    uses a confirmation number (CNUM).
    //
    //	   TICKET   Browser Local Memory Item, stored
    //		    using EMAIL as the item key when
    //		    the browser is notified that the
    //              MANUAL browser id protocol has been
    //              successfully completed.  Just the
    //              single line:
    //
    //			BID KEYA KEYB CTIME
    //
    //		    in the browser local memory.
    //
    //      FTIME   STIME of first time user was
    //              confirmed.
    //
    //      CCOUNT  Number of times user has been
    //              confirmed.
    //
    //   EMAIL-FILE The file EDIR/EMAIL (where here only
    //		    EMAIL is encoded by rawurlencode)
    //              that contains just the line:
    //
    //			USER_ID FTIME CCOUNT
    //
    //		    File is initialized by user_edit.php
    //		    when user first logs in, after
    //		    confirmation.  CCOUNT is updated
    //		    by this page on subsequent confirma-
    //              tions.
    //
    // When the browser identification protocol
    // successfully complete, the server sets the
    // the following values in $_SESSION:
    //
    //    EPM_EMAIL => EMAIL
    //    EPM_BROWSER_ID => BID
    //    EPM_USER_ID => UID, but not set for new user.
    //
    // Next page is page/problem_select.php if user is
    // NOT new and page/user_edit.php otherwise.  In
    // the case of a new user, this last page determines
    // UID and sets EPM_USER_ID.
    //
    // During the execution of the browser identifica-
    // tion protocol, $_SESSION['EPM_BROWSER_DATA']
    // is used to hold BID, EMAIL, CTIME, KEYA, KEYB,
    // CNUM, UID, FTIME, and CCOUNT.  During the proto-
    // col the browser stores BID, EMAIL, CTIME, KEYA,
    // KEYB, and CNUM in var's of the same name.
    //
    // Each execution of the browser identification
    // protocol is logged separately to the file:
    //
    //		admin/login.log
    //
    // if that file exists and is writeable. The file
    // format is
    //
    //	 // comment
    //   BID EMAIL UID IPADDR STIME CTIME FTIME CCOUNT
    //
    // where IPADDR is $_SESSION['EPM_IPADDR'] and for
    // a new user UID is 'NEW', CTIME and FTIME equal
    // STIME, and CCOUNT is 1.


    // Browser Identification Protocol
    // -------------------------------
    //
    // The browser runs the protocol using javascript
    // XMLHttpRequest to POST requests.  When the
    // browser is notified of success, it is given
    // a page to go to (page/problem_select.php or
    // for new users page/user_edit.php).
    //
    // The protocol is:
    //
    // BEGIN:
    //	   * AUTO_RETRY = 0
    //     * Get EMAIL from user.
    //	   * Get TICKET = localStorage.getItem(EMAIL)
    //	   * If TICKET != null:
    //		* Parse TICKET to get BID, KEYA, KEYB
    //          * MANUAL = no
    //          * go to AUTO_ID
    // MANUAL_ID:
    //	   * MANUAL = yes
    //     * Send 'op=MANUAL&value=EMAIL'
    //     * Receive one of:
    //           'BAD_EMAIL': FAIL
    //           'NEW BID EKEYA EKEYB CTIME' where
    //                    EKEYA, EKEYB are KEYA, KEYB
    //                    encrypted using CNUM.
    // EXPIRED:
    //     * Get CNUM from user.
    //     * Decrypt EKEYA and EKEYB using CNUM to get
    //	     KEYA, KEYB.
    // AUTO_ID:
    //     * AUTO_RETRY += 1
    //     * If AUTO_RETRY > 2: FAIL
    //     * Send 'op=AUTO&value=BID'
    //	   * Receive one of:
    //           'EXPIRED BID EKEYA EKEYB CTIME':
    //               go to EXPIRED
    //           'FAIL':  (means BID not recognized)
    //               go to AUTO_ID
    //		 'SHAKE HANDSHAKE':
    //               continue with following
    //     * Decrypt HANDSHAKE using KEYA and encrypt
    //       result using KEYB to get SHAKEHAND.
    //     * Send 'op=SHAKE&value=SHAKEHAND'
    //     * Receive one of:
    //           'FAIL':
    //               go to AUTO_ID
    //           'DONE NEXT_PAGE':
    //               continue with following
    //     * If MANUAL:
    //		* TICKET = 'BID KEYA KEYB CTIME'
    //          * localStorage.setItem(EMAIL,TICKET)
    //     * Issue GET to NEXT_PAGE
    //
    // The server generates bid, keyA, keyB, confirma-
    // tion number and handshake as 128-bit binary
    // strings.  Encrypted values are binary strings.
    // Binary strings are transmitted as hexadecimal
    // strings.  Ctime is the time that the browser was
    // last confirmed, or the time the server receives
    // the MANUAL post, and is in '%FT%T%z' (ISO 8601)
    // format.  The browser does not use it in the
    // protocol.
    //
    // Encryption is by AES-128-CRC with zero initial
    // vector.  All encrypted items are 128 bit random
    // numbers.
    //
    // Multiple invocations of MANUAL for the same
    // session with the same EMAIL will use the same
    // cnumber, so as not to confuse the user.

    require "{$_SERVER['DOCUMENT_ROOT']}/index.php";
    umask ( 07 );

    // require "$include/debug_info.php";

    if ( ! isset ( $_SESSION['EPM_BROWSER_DATA'] ) )
	$_SESSION['EPM_BROWSER_DATA'] = [];
    $data = & $_SESSION['EPM_BROWSER_DATA'];

    // Read $epm_data/admin/email/$email(encoded) if it
    // exists and if read set $data UID, FTIME, CCOUNT.
    //
    function read_email_file ( $email )
    {
        global $epm_data, $data;

	$efile = "$epm_data/admin/email/"
	       . rawurlencode ( $email );

	if ( ! is_readable ( $efile ) ) return;

	$c = file_get_contents ( $efile );
	if ( $c === false )
	    ERROR ( "failed to read readable" .
		    " file $efile" );
	$c = trim ( $c );
	$item = explode ( ' ', $c );
	if ( count ( $item ) != 3 )
	    ERROR ( "$efile value '$e' badly" .
		    " formatted" );
	$data['UID'] = $item[0];
	$data['FTIME'] = $item[1];
	$data['CCOUNT'] = $item[2];
    }

    // Output NEW or EXPIRED response, creating CNUM is
    // necessary.  Note: CNUM is set iff a new ticket
    // has been created, and its bid-file should be
    // written and email-file CCOUNT incremented upon
    // successful handshake).
    //
    function new_ticket_response ( $email, $op )
    {
        global $epm_data, $data;

	if ( isset ( $data['EMAIL'] )
	     &&
	     $data['EMAIL'] == $email )
	{
	    if ( isset ( $data['BID'] ) )
	    {
		$bfile = "$epm_data/admin/browser/"
		       . $data['BID'];
		if ( file_exists ( $bfile ) )
		    unlink ( $bfile );
	    }
	    if ( ! isset ( $data['CNUM'] ) )
		$data['CNUM'] =
		    bin2hex ( random_bytes ( 16 ) );
	}
	else
	{
	    $data['EMAIL'] = $email;
	    $data['CNUM'] =
		bin2hex ( random_bytes ( 16 ) );
	    read_email_file ( $email );
	}

	$sname = $_SERVER['SERVER_NAME'];
	mail ( $data['EMAIL'],
	       "Your EPM Confirmation Number",
	       "Your EPM $sname confirmation number" .
	       " is:\r\n" .
	       "\r\n" .
	       "     {$data['CNUM']}\r\n",
	       ["From" => "no_reply@$sname"] );

	$data['BID'] = bin2hex ( random_bytes ( 16 ) );
	$data['KEYA'] = bin2hex ( random_bytes ( 16 ) );
	$data['KEYB'] = bin2hex ( random_bytes ( 16 ) );
	$data['CTIME'] = $_SESSION['EPM_SESSION_TIME'];

	$iv = hex2bin
	    ( "00000000000000000000000000000000" );
	$ekeyA = bin2hex ( openssl_encrypt
	    ( hex2bin ( $data['KEYA'] ), "aes-128-cbc",
	      hex2bin ( $data['CNUM'] ),
	      OPENSSL_RAW_DATA, $iv ) );
	$ekeyB = bin2hex ( openssl_encrypt
	    ( hex2bin ( $data['KEYB'] ), "aes-128-cbc",
	      hex2bin ( $data['CNUM'] ),
	      OPENSSL_RAW_DATA, $iv ) );

	echo ( "$op {$data['BID'} $ekeyA $ekeyB" .
	       " {$data['CTIME']}" );
    }

    $op = NULL;
    if ( isset ( $_POST['op'] ) )
        $op = $_POST['op'];

    // Process POSTs from xhttp.
    //
    if ( $op == 'MANUAL_ID' )
    {
	$email = trim ( $_POST['value'] );
	$e = filter_var
	    ( $email, FILTER_SANITIZE_EMAIL );

	if ( $e != $email
	     ||
	     ! filter_var
		      ( $email,
			FILTER_VALIDATE_EMAIL ) )
	{
	    echo ( 'BAD_EMAIL' );
	    exit;
	}
        new_ticket_response ( '$email, NEW' );
	exit;
    }
    elseif ( $op == 'AUTO' )
    {
	$bid = trim ( $_POST['value'] );
	if ( ! preg_match ( '/^[a-fA-F0-9]{32}$/',
	                    $bid ) ) 
	{
	    echo ( 'FAIL' );
	    exit;
	}
	$bfile = "$epm_data/admin/browser/$bid";
	if ( ! is_readable ( $bfile ) )
	{
	    if ( ! isset ( $data['EMAIL'] ) )
	    {
	        echo ( 'FAIL' );
		exit;
	    }
	    // Else this is part of MANUAL login.
	}
	else
	{
	    $c = file_get_contents ( $bfile );
	    if ( $c === false )
	        ERROR ( "cannot read readable file" .
		        " $bfile" );
	    $c = trim ( $c );
	    $item = explode ( ' ', $c );
	    if ( count ( $item ) != 4 )
	        ERROR ( "$bfile value '$c' badly" .
		        " formatted" );
	    $email = $item[1];
	    if ( ! isset ( $data['EMAIL'] )
		 ||
	         $email != $data['EMAIL'] )
	    {
		$data['EMAIL'] = $email;
		unset ( $data['CNUM'] );
		read_email_file ( $email );
	    }
	    $expired = false;
	    if ( isset ( $data['CCOUNT'] )
	         &&
		 isset ( $data['CTIME'] )
	    {
	        $ccount = $data['CCOUNT'];
		$ctime = strtotime['CTIME'];
		$now = time();

		$etimes = & $epm_expiration_times;
		$ecount = count ( $etimes );
		if ( $ccount >= $ecount )
		    $ccount = $ecount - 1;
		$etime = $now + $etimes[$ccount];
		if ( $etime < $now )
		    $expired = true;
	    }

	    if ( $expired )
	    {
	        @unlink ( $bfile );
		new_ticket_response
		    ( $email, 'EXPIRED' );
		exit;
	    }
	         
	    $data['KEYA'] = $item[2];
	    $data['KEYB'] = $item[3];
	}

	$data['HANDSHAKE'] =
	    bin2hex ( random_bytes ( 16 ) );
	$iv = hex2bin
	    ( "00000000000000000000000000000000" );
	$handshake = bin2hex ( openssl_encrypt
	    ( hex2bin ( $data['KEYA'] ), "aes-128-cbc",
	      hex2bin ( $data['HANDSHAKE'] ),
	      OPENSSL_RAW_DATA, $iv ) );

	echo ( "SHAKE $handshake" );
	exit;
    }
    elseif ( $op == 'SHAKE' )
    {
	$shakehand = trim ( $_POST['value'] );
	if ( ! preg_match ( '/^[a-fA-F0-9]{32}$/',
	                    $shakehand ) ) 
	{
	    echo ( 'FAIL' );
	    exit;
	}
	$iv = hex2bin
	    ( "00000000000000000000000000000000" );
	$handshake = bin2hex ( openssl_decrypt
	    ( hex2bin ( $data['KEYB'] ), "aes-128-cbc",
	      hex2bin ( $shakehand ),
	      OPENSSL_RAW_DATA, $iv ) );

	if ( $handshake != $data['HANDSHAKE'] )
	    echo ( 'FAIL' );
	else
	{
	    $next_page = 'user_edit.php';
	    if ( isset ( $data['UID'] ) )
	    {
		$next_page = 'problem.php';
		$_SESSION['EPM_USER_ID'] = $data['UID'];

		if ( isset ( $data['CNUM'] ) )
		{
		    $efile = "$epm_data/admin/email"
			   . rawurlencode
			       ( $data['EMAIL'] );
		    $data['CCOUNT'] += 1;
		    $item = [ $data['UID'],
			      $data['FTIME'],
			      $data['CCOUNT'] ];
		    file_put_contents
			( $efile,
			  implode ( ' ', $item ) );
		}
	    }

	    if ( isset ( $data['CNUM'] ) )
	    {
		$bfile = "$epm_data/admin/browser/"
		       . $data['BID'];
		$item = [ $data['EMAIL'],
			  $data['KEYA'],
			  $data['KEYB'],
			  $data['CTIME'] ];
		file_put_contents
		    ( $bfile, implode ( ' ', $item ) );
	    }

	    $_SESSION['EPM_BROWSER_ID'] = $data['BID'];
	    $_SESSION['EPM_EMAIL'] = $data['EMAIL'];

	    $lfile = "$epm_data/admin/login.log";
	    if ( is_writable ( $lfile ) )
	    {
		$stime = $_SESSION['EPM_SESSION_TIME'];
		if ( isset ( $data['UID'] ) )
		    $item = [ $data['BID'],
			      $data['EMAIL'],
			      $data['UID'],
			      $_SESSION['EPM_IPADDR'],
			      $stime,
			      $data['CTIME'],
			      $data['FTIME'],
			      $data['CCOUNT'] ]'
		else
		    $item = [ $data['BID'],
			      $data['EMAIL'],
			      'NEW',
			      $_SESSION['EPM_IPADDR'],
			      $stime,
			      $stime,
			      $stime,
			      1 ]'
		file_put_contents
		    ( $lfile, implode ( ' ', $item ),
		      FILE_APPEND );
	    }

	    unset ( $_SESSION['EPM_BROWSER_DATA'] );
	    echo ( "DONE $next_page" );
	}
	exit;
    }
    elseif ( $_SERVER['REQUEST_METHOD'] != 'GET' )
        exit ( "unacceptable method" .
	       " {$_SERVER['REQUEST_METHOD'}" );

    // Else load html and script.

?>


<html>

<body>
<!-- body elements must be BEFORE script so that
     getElementById can be used to set global vars -->

<div id='get_email' style.display='none'>
<input type='text' id='email_in'
       placeholder='Enter Email Address'>
</div>

<div id='show_email' style.display='none'>
Email:&nbsp;<span id='email_out'></span>
<button onclick="window.location.reload(true)">
Retry Login from Beginning
</button>
<br>
<button onclick="RESET_EMAIL()">
Re-confirm above email address.
</button>
<br>
<button onclick="RESET_BROWSER()">
Reset Browser
</button><br>
(You will have reconfirm all email addresses used with this browser.)
</div>

<div id='get_cnum' style.display='none'>
A Confirmation Number has been sent to the above Email Address.
<br>
Please <input type='text' id='cnum_in'
       placeholder='Enter Confirmation Number'>
</div>

<script>

var LOG = function(message) {};  // Disable logging.
var LOG = console.log;           // Enable logging.

var xhttp = new XMLHttpRequest();
var storage = window.localStorage;
var get_email = document.getElementById("get_email")'
var show_email = document.getElementById("show_email")'
var get_cnum = document.getElementById("get_cnum")'

function FAIL ( message )
{
    // Alert must be scheduled as separate task.
    //
    setTimeout ( function () {
	alert ( message );
	window.location.reload ( true );
    });
}

function RESET_EMAIL()
{
    storage.removeItem ( EMAIL );
    window.location.reload ( true );
}

function RESET_BROWSER()
{
    storage.clear();
    window.location.reload ( true );
}

function ALERT ( message )
{
    // Alert must be scheduled as separate task.
    //
    setTimeout ( function () { alert ( message ); } );
}

var REQUUEST_IN_PROGRESS = false;
function SEND ( data, callback, error_message )
{
    xhttp.onreadystatechange = function() {
	LOG ( 'xhttp state changed to '
	      + this.readyState );
	if ( this.readyState !== XMLHttpRequest.DONE )
	    return;

	if ( this.status != 200 )
	    FAIL ( 'Bad response status (' + this.status
	           + ') from server on '
	           + error_message );
	else if ( REQUEST_IN_PROGRESS )
	{
	    REQUEST_IN_PROGRESS = false;
	    LOG ( 'xhttp response: '
	          + this.responseText );
	    callback ( this.responseText )
	}
    };
    xhttp.open ( 'POST', "login.php", true );
    xhttp.setRequestHeader
        ( "Content-Type",
	  "application/x-www-form-urlencoded" );
    REQUEST_IN_PROGRESS = true;
    LOG ( 'xhttp sent: ' + data );
    xhttp.send ( data );
}

var IMPORTKEY, ENCRYPT, DECRYPT;
var IV = new Uint8Array ( 16 );
    // 16 zero bytes.

if ( window.msCrypto !== undefined )
{

    IMPORTKEY = function ( key, callback )
    {
	window.msCrypto.subtle.importKey
	    ( "raw", hex2ArrayBuffer ( key ),
	      "AES-CBC", true, ["encrypt", "decrypt"] )
	    .oncomplete
	        ( function(r)
		  { callback ( r.target.result ) } )
	    .onerror
	        ( function(r)
		  { callback
		      ( new Error
		          ( 'key import failed' ) ) } );
    }

    ENCRYPT = function ( cryptokey, data, callback )
    {
	window.msCrypto.subtle.encrypt
	    ( { name: "AES-CBC", iv }, cryptokey,
	      hex2ArrayBuffer ( data ) )
	    .oncomplete
	        ( function(r)
		  { callback
		      ( ArrayBuffer2hex
		          ( r.target.result ) ) } )
	    .onerror
	        ( function(r)
		  { callback
		      ( new Error
		          ( 'encryption failed' ) ) } );
    }

    DECRYPT = function ( cryptokey, data, callback )
    {
	window.msCrypto.subtle.decrypt
	    ( { name: "AES-CBC", iv }, cryptokey,
	      hex2ArrayBuffer ( data ) )
	    .oncomplete
	        ( function(r)
		  { callback
		      ( ArrayBuffer2hex
		          ( r.target.result ) ) } )
	    .onerror
	        ( function(r)
		  { callback
		      ( new Error
		          ( 'decryption failed' ) ) } );
    }

} else {

    IMPORTKEY = function ( key, callback )
    {
	window.crypto.subtle.importKey
	    ( "raw", hex2ArrayBuffer ( key ),
	      "AES-CBC", true, ["encrypt", "decrypt"] )
	    .then ( callback )
	    .catch
	        ( function(r)
		  { callback
		      ( new Error
		          ( 'key import failed' ) ) } );
    }

    ENCRYPT = function ( cryptokey, data, callback )
    {
	window.crypto.subtle.encrypt
	    ( { name: "AES-CBC", iv }, cryptokey,
	      hex2ArrayBuffer ( data ) )
	    .then
	        ( function(r)
		  { callback
		      ( ArrayBuffer2hex ( r ) ) } )
	    .catch
	        ( function(r)
		  { callback
		      ( new Error
		          ( 'encryption failed' ) ) } );
    }

    DECRYPT = function ( cryptokey, data, callback )
    {
	window.crypto.subtle.decrypt
	    ( { name: "AES-CBC", iv }, cryptokey,
	      hex2ArrayBuffer ( data ) )
	    .then
	        ( function(r)
		  { callback
		      ( ArrayBuffer2hex ( r ) ) } )
	    .catch
	        ( function(r)
		  { callback
		      ( new Error
		          ( 'decryption failed' ) ) } );
    }

}
    
var AUTO_RETRY, EMAIL, TICKET, BID, KEYA, KEYB, CTIME,
    MANUAL, CNUM, CRYPTOKEY, HANDSHAKE, SHAKEHAND;

// BEGIN:
//
AUTO_RETRY = 0;
EMAIL = null;
TICKET = null;
show_email.style.display = 'none';
GET_EMAIL_ENABLED = true;
get_email.style.display = 'block';

var GET_EMAIL_ENABLED = false;
function EMAIL_KEYDOWN ( event )
{
    if ( event.code == 'Enter'
         &&
	 GET_EMAIL_ENABLED )
    {
	var value = email.value.trim();
	if ( /^\S+@\S+\.\S+$/.test(value) )
	{
	    GET_EMAIL_ENABLED = false;
	    GOT_EMAIL ( value );
	}
	else if ( value != '' )
	    ALERT ( value + " is not a valid" +
	            " email address" );
    }
}
email_in.addEventListener ( 'keydown', EMAIL_KEYDOWN );

function GOT_EMAIL ( email )
{
    EMAIL = email;
    get_email.style.display = 'none';
    email_out.innerHTML = EMAIL;
    show_email.style.display = 'block';
    TICKET = storage.getItem(EMAIL);
    if ( item == null )
        MANUAL_ID();
    else
    {
        var TICKETlist = TICKET.split ( ' ' );
	BID = TICKETlist[0];
	KEYA = TICKETlist[1];
	KEYB = TICKETlist[2];
	MANUAL = false;
	AUTO_ID();
    }
}

function MANUAL_ID()
{
    MANUAL = true;
    SEND ( "op=MANUAL&value="
           + encodeURIComponent ( EMAIL ),
           MANUAL_RESPONSE,
	   'sending ' + EMAIL + ' to server' );
}

function MANUAL_RESPONSE ( response )
{
    var r = response.split ( ' ' );
    if ( r[0] == 'NOT_EMAIL' )
        FAIL ( EMAIL +
	       ' is not a valid email address' );
    else if ( r[0] != 'NEW'
	      ||
	      r.length != 5 )
        FAIL ( 'Response from server on sending '
	       + EMAIL + ' to server is malformed' );
    else
    {
	BID = r[1];
	EKEYA = r[2];
	EKEYB = r[3];
	CTIME = r[4];
	EXPIRED();
    }
};

function EXPIRED()
{
    GET_CNUM_ENABLED = true;
    get_cnum.style.display = 'block';
}

var GET_CNUM_ENABLED = false;
function CNUM_KEYDOWN ( event )
{
    if ( event.code == 'Enter'
         &&
	 GET_CNUM_ENABLED )
    {
	value = cnum.value.trim();
	if ( /^[a-f0-9]{32}$/.test(value) )
	{
	    GET_CNUM_ENABLED = false;
	    GOT_CNUM ( value );
	}
	else if ( value != '' )
	    ALERT ( value + ' is not a valid' +
	            ' confirmation number' )';
    }
}
cnum_in.addEventListener ( 'keydown', CNUM_KEYDOWN );

function GOT_CNUM ( cnum )
{
    CNUM = cnum;
    IMPORTKEY ( cnum, GOT_CNUM_KEY );
}

function CNUM_NOT_VALID()
{
    alert ( CNUM + ' is not valid;'
	    + ' try again or reset' );
    EXPIRED();
}

function GOT_CNUM_KEY ( cryptokey )
{
    if ( cryptokey instanceof Error )
    {
        CNUM_NOT_VALID();
	return;
    }
    CRYPTOKEY = cryptokey;
    DECRYPT ( EKEYA, CRYPTOKEY, GOT_KEYA );
}

function GOT_KEYA ( keyA )
{
    if ( keyA instanceof Error )
    {
        CNUM_NOT_VALID();
	return;
    }
    KEYA = keyA;
    DECRYPT ( EKEYB, CRYPTOKEY, GOT_KEYB );
}

function GOT_KEYB ( keyB )
{
    if ( keyB instanceof Error )
    {
        CNUM_NOT_VALID();
	return;
    }
    KEYB = keyB;
    AUTO_ID();
}

function AUTO_ID()
{
    AUTO_RETRY += 1
    if ( AUTO_RETRY > 2 )
        FAIL ( 'two attempts at handshake failed' );
    SEND ( 'op=AUTO&value=' + BID,
           AUTO_RESPONSE,
	   'starting handshake with server' );
}

function AUTO_RESPONSE ( item )
{
    item = item.split ( ' ' );
    if ( item[0] == 'EXPIRED' )
    {
	storage.removeItem ( EMAIL );
        if ( item.length != 5 )
	    FAIL ( 'bad response from server during'
	           + ' handshake; re-confirmation'
		   + ' required' );
	BID   = item[1];
	EKEYA = item[2];
	EKEYB = item[3];
	CTIME = item[4];
	EXPIRED();
	return;
    }
    else if ( item[0] == 'FAIL' )
    {
	storage.removeItem ( EMAIL );
	FAIL ( 'browser/email not known to server;'
	       + ' re-confirmation required' );
    }
    else if ( item[0] == 'SHAKE' )
    {
        HANDSHAKE = item[1];
	IMPORTKEY ( KEYA, GOT_KEYA );
    }
    else
        FAIL ( 'Response from server on sending'
	       + 'browser ID to server is malformed' );
}

function GOT_KEYA ( cryptokey )
{
    if ( cryptokey instanceof Error )
    {
        AUTO_ID();  // Retry
	return;
    }
    DECRYPT ( HANDSHAKE, cryptokey, GOT_SHAKEA );
}

function GOT_SHAKEA ( shakeA )
{
    if ( cryptokey instanceof Error )
    {
        AUTO_ID();  // Retry
	return;
    }
    SHAKEHAND = shakeA;
    IMPORTKEY ( KEYB, GOT_KEYB );
}

function GOT_KEYB ( cryptokey )
{
    if ( cryptokey instanceof Error )
    {
        AUTO_ID();  // Retry
	return;
    }
    ENCRYPT ( SHAKEHAND, cryptokey, GOT_SHAKEB );
}

function GOT_SHAKEB ( shakeB )
{
    if ( cryptokey instanceof Error )
    {
        AUTO_ID();  // Retry
	return;
    }
    SHAKEHAND = shakeB;
    SEND ( 'op=HAND&value=' + SHAKEHAND,
           SHAKE_RESPONSE,
	   'sending handshake to server' );
}

function SHAKE_RESPONSE ( item )
{
    item = item.split ( ' ' );
    if ( item[0] == 'FAIL' )
    {
        AUTO_ID();  // Retry
	return;
    }
    else if ( item[0] == 'DONE'
              &&
	      item.length == 2 )
    {
        TICKET = [BID, KEYA, KEYB, CTIME].join(' ');
        if ( MANUAL )
	    storage.storeItem ( EMAIL, TICKET );
	try {
	    window.location.assign ( item[2] );
	} catch ( e ) {
	    FAIL
	       ( 'could not access page ' + item[2] );
	       // On retry login.php will go to
	       // correct page.
    }
    else
        FAIL ( 'Response from server on sending'
	       + 'browser ID to server is malformed' );
}
    
</script>


</body>
</html>
