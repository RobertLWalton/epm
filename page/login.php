<?php

    // File:	login.php
    // Author:	Robert L Walton <walton@acm.org>
    // Date:	Sat Jun 27 06:30:23 EDT 2020

    // The authors have placed EPM (its files and the
    // content of these files) in the public domain;
    // they make no warranty and accept no liability
    // for EPM.

    // Handles login for an EPM session.
    //
    // Data:
    //
    //    BDIR	    Browser data directory:
    //                $epm_data/admin/browser
    //
    //    EDIR	    Email data directory:
    //                $epm_data/admin/email
    //
    //    EMAIL	    User email address.  Used as the
    //              user name.
    //
    //    UID	    User ID.  Name containing only
    //		    letters, digits, _, and - and
    //		    beginning and ending with a letter.
    //
    //    BID	    Browser ID.  A 32-hex-digit random
    //		    number generated by the server to
    //		    identify the browser.  Changed
    //		    every time the browser logs in.
    //		    When sent by e-mail to the user,
    //		    is called the confirmation number.
    //
    //    STIME     Session Time.  The time of the
    //		    request that created the current
    //		    session, as stored in $_SESSION
    //		    ['EPM_SESSION_TIME'] in $epm_time_
    //		    format.
    //
    //    RTIME	    Last required email confirmation.
    //
    //    RCOUNT    Number of successful required
    //              confirmations.
    //
    //    BID-FILE  The file BDIR/BID that contains just
    //		    the line:
    //
    //			EMAIL
    //
    //		    File is written by server when it
    //		    sends a BID, either by e-mail or by
    //		    xhttp.
    //
    //   EMAIL-FILE The file EDIR/EMAIL (where here
    //		    EMAIL is encoded by rawurlencode)
    //              that contains just the line:
    //
    //		    UID RCOUNT RTIME
    //
    //		    File is initialized by user.php
    //		    when user first logs in, after
    //		    confirmation, or when a user adds
    //		    an email to his account.  This file
    //		    is updated by this page when issuing
    //		    a new required confirmation for this
    //		    email.
    //
    //    PATH	    The path component of the URL used
    //		    to log in.  This always ends with
    //		    `/page/login.php', precisely.
    //
    //	  TICKET    Stored by the browser in its local
    //		    memory, which is specific to the
    //		    URL root used to message the EPM
    //		    server.  The TICKET is just the BID
    //		    stored under the name PATH\0EMAIL.
    //
    // When the browser identification protocol
    // successfully completes, the server sets the
    // the following values in $_SESSION:
    //
    //    EPM_EMAIL => EMAIL
    //    EPM_UID => UID, but not set by this
    //                    program for a new user.
    //
    // Next page is page/project.php if user is NOT new
    // and page/user.php otherwise.  In the case of a
    // new user, this last page determines UID, sets
    // EPM_UID, and creates EMAIL-FILE.
    //
    // Each successful execution of the browser identi-
    // fication protocol (i.e., each successful login)
    // is logged separately to the file:
    //
    //		$epm_data/login.log
    //
    // The format of this file is
    //
    //	 // comment
    //   UID EMAIL IPADDR STIME
    //
    // where IPADDR is $_SESSION['EPM_IPADDR'] and for
    // a new user UID is 'NEW'.


    // Browser Identification Protocol
    // -------------------------------
    //
    // The browser runs the protocol using javascript
    // XMLHttpRequest to POST requests.  When the
    // browser is notified of success, it is given
    // a page to go to (page/project.php or for new
    // users page/user.php).
    //
    // The protocol is:
    //
    // BEGIN:
    //	   * Set PATH = location.pathname.
    //     * Get EMAIL from user.
    //	   * Get BID = localStorage.getItem(PATH\0EMAIL)
    //	   * If BID != null:
    //          * go to AUTO_ID
    // MANUAL_ID:
    //     * Send 'op=MANUAL&value=EMAIL'
    //     * Receive one of:
    //           'BAD_EMAIL': go to FAIL
    //           'BLOCKED_EMAIL': go to FAIL
    //           'NEW': go to CONFIRM
    // AUTO_ID:
    //     * Send 'op=AUTO&value=BID'
    //	   * Receive one of:
    //           'EXPIRED':
    //               go to CONFIRM
    //           'BLOCKED_EMAIL':
    //		     go to FAIL
    //           'FAIL':  (means BID not recognized)
    //               go to MANUAL_ID
    //		 'RENEW BID NEXT_PAGE'
    //		     go to FINISH
    // CONFIRM:
    //     * Get BID = confirmation number from user.
    //     * go to AUTO_ID
    // FINISH:
    //     * localStorage.setItem(PATH\0EMAIL,BID)
    //     * Issue GET to NEXT_PAGE
    // FAIL:
    //     * Output message
    //     * reload

    if ( $_SERVER['REQUEST_METHOD'] == 'GET' )
        $epm_page_type = '+init+';
    else
        $epm_page_type = '+main+';
    require __DIR__ . '/index.php';
    require __DIR__ . '/../include/epm_random.php';
    // require __DIR__ . '/../include/debug_info.php';

    if ( $epm_method == 'GET' )
    {
        $_SESSION['EPM_ID_GEN']['+main+'] =
	    init_id_gen();
	$ID = bin2hex
	    ( $_SESSION['EPM_ID_GEN']['+main+'][0] );

	if ( isset ( $_SESSION['EPM_UID'] ) )
	{
	    header ( "location: project.php?id=$ID" );
	    exit;
	}

	$_SESSION['EPM_SESSION_TIME'] =
	    strftime ( $epm_time_format,
	               $_SERVER['REQUEST_TIME'] );
	$_SESSION['EPM_IPADDR'] =
	    $_SERVER['REMOTE_ADDR'];

	file_put_contents
	    ( "$epm_data/error.log",
	      'NEW_SESSION ' .
	      $_SESSION['EPM_SESSION_TIME'] . ' ' .
	      $_SESSION['EPM_IPADDR'] . PHP_EOL,
	      FILE_APPEND );
    }
    else
	DEBUG ( 'POST ' . json_encode ( $_POST ) );

    $STIME = $_SESSION['EPM_SESSION_TIME'];

    // Values read from EMAIL-FILE if that exists and
    // has been read.
    //
    $uid = NULL;
    $rcount = NULL;
    $rtime = NULL;

    // Reply to POST from xhttp.
    //
    function reply ( $reply )
    {
        global $ID;
	echo ( "$ID $reply" );
	DEBUG ( "REPLY $ID $reply" );
	exit;
    }

    // Check admin/+blocking+ file to determine whether
    // email is blocked.
    //
    function is_blocked ( $email )
    {
        global $epm_data;
	$f = 'admin/+blocking+';
	$c = @file_get_contents ( "$epm_data/$f" );
	if ( $c === false ) return false;
	$c = explode ( "\n", $c );
	$line_re = '/^(\+|\-)\s+(\S+)$/';
	foreach ( $c as $line )
	{
	    $line = trim ( $line );
	    if ( $line == '' ) continue;
	    if ( ! preg_match
	               ( $line_re, $line, $matches ) )
	        ERROR ( "bad $f line: $line" );
	    $sign = $matches[1];
	    $re   = $matches[2];
	    $r = preg_match ( "/^($re)\$/", $email );
	    if ( $r === false )
	        ERROR ( "bad $f RE: $line" );
	    if ( $r == 0 ) continue;
	    return ( $sign == '-' );
	}
    }

    // Read $epm_data/admin/email/$email(encoded) if it
    // exists and if read set $uid, $rcount, $rtime.
    //
    function read_email_file ( $email )
    {
	global $epm_data, $uid, $rcount, $rtime;

	$uid = NULL;
	$rcount = NULL;
	$rtime = NULL;

	$efile = "admin/email/"
	       . rawurlencode ( $email );

	if ( ! is_readable ( "$epm_data/$efile" ) )
	    return;

	$c = @file_get_contents ( "$epm_data/$efile" );
	if ( $c === false )
	    ERROR ( "failed to read readable" .
		    " file $efile" );
	$c = trim ( $c );
	$items = explode ( ' ', $c );
	if ( count ( $items ) != 3 )
	    ERROR ( "$efile value '$c' badly" .
		    " formatted" );
	$uid = $items[0];
	$rcount = $items[1];
	$rtime = $items[2];
    }

    // Create new BID and its BID-FILE and return
    // new bid.
    //
    function new_bid ( $email )
    {
	global $epm_data;

	while ( true )
	{
	    $bid = bin2hex ( random_16_bytes ( 16 ) );
	    $bfile = "admin/browser/$bid";
	    if ( is_readable ( "$epm_data/$bfile" ) )
	    {
	        WARN ( 'THIS SHOULD NEVER HAPPEN' );
	        continue;
	    }
	    file_put_contents
	        ( "$epm_data/$bfile",
	          $email . PHP_EOL );
	    return $bid;
	}
    }

    // Output NEW or EXPIRED response, creating
    // confirmation number and BID-FILE.  $op is
    // NEW or EXPIRED.
    //
    function confirmation_reply ( $email, $op )
    {
        global $uid;

	$bid = new_bid ( $email );

	$sname = $_SERVER['SERVER_NAME'];
	$r = mail ( $data['EMAIL'],
	       "Your EPM Confirmation Number",
	       "Your EPM $sname confirmation number" .
	       " is:\r\n" .
	       "\r\n" .
	       "     {$data['CNUM']}\r\n",
	       "From: no_reply@$sname" );
	if ( $r === false )
	    ERROR ( "mailer failed" );

	reply ( "$op $bid" );
    }

    $op = NULL;
    if ( isset ( $_POST['op'] ) )
	$op = $_POST['op'];

    // Process POSTs from xhttp.
    //
    if ( $op == 'MANUAL' )
    {
	$email = trim ( $_POST['value'] );
	$e = filter_var
	    ( $email, FILTER_SANITIZE_EMAIL );

	if ( $e != $email
	     ||
	     ! filter_var
		      ( $email,
			FILTER_VALIDATE_EMAIL ) )
	    reply ( 'BAD_EMAIL' );
	elseif ( is_blocked ( $email ) )
	    reply ( 'BLOCKED_EMAIL' );
	else
	    confirmation_reply ( $email, 'NEW' );
    }
    elseif ( $op == 'AUTO' )
    {
	$bid = trim ( $_POST['value'] );
	if ( ! preg_match ( '/^[a-fA-F0-9]{32}$/',
			    $bid ) ) 
	    reply ( 'FAIL' );
	$bfile = "admin/browser/$bid";
	if ( ! is_readable ( "$epm_data/$bfile" ) )
		reply ( 'FAIL' );

	$c = @file_get_contents
	    ( "$epm_data/$bfile" );
	if ( $c === false )
	    ERROR ( "cannot read readable file" .
		    " $bfile" );
	$email = trim ( $c );
	if ( is_blocked ( $email ) )
	    reply ( 'BLOCKED_EMAIL' );

	@unlink ( "$epm_data/$bfile" );
	read_email_file ( $email );

	if ( isset ( $uid ) )
	{
	    $now = time();

	    $etimes = & $epm_expiration_times;
	    $n = count ( $etimes );
	    if ( $rcount >= $n )
		$rcount = $n - 1;
	    $rtime = strtotime ( $rtime );
	    if (   $rtime + $etimes[$rcount]
		 < $now )
	    {
		$efile = "admin/email/"
		       . rawurlencode ( $email );
		++ $rcount;
		$rtime = strtotime
		    ( $epm_time_format );
		$r = file_put_contents
		    ( "$epm_data/$efile",
		      "$uid $rcount $rtime" );
		confirmation_reply
		    ( $email, 'EXPIRED' );
	    }
	    $next_page = 'project.php';
	    $_SESSION['EPM_UID'] = $uid;

	    // If $uid exists, so does
	    // /admin/users/$uid
	    //
	    $f = "/admin/users/$uid" .
		 "/session_id";
	    $r = file_put_contents
		( "$epm_data/$f", session_id() );
	    if ( $r === false )
		ERROR ( "cannot write $f" );
	    $fmtime = @filemtime ( "$epm_data/$f" );
	    if ( $fmtime === false )
		ERROR ( "cannot stat $f" );
	    $_SESSION['EPM_SESSION'] = [$f,$fmtime];

	}
	else
	    $next_page = 'user.php';

	$_SESSION['EPM_EMAIL'] = $email;
	$bid = new_bid ( $email );
	reply ( "RENEW $bid $next_page" );
    }
    elseif ( $epm_method == 'POST' )
	exit ( "UNACCEPTABLE HTTP POST" );

    // Else load html and script.

?>

<html>
<head>
<?php require __DIR__ . '/../include/epm_head.php'; ?>

<style>
    button, input, mark, span, pre {
        font-size: var(--large-font-size);
    }
    #get_email, #show_email {
	background-color: #96F9F3;
	padding: var(--indent);
        font-size: var(--large-font-size);
    }
    #get_cnum {
	background-color: #80FFCC;
	padding: var(--indent);
        font-size: var(--large-font-size);
    }
</style>
</head>

<body>
<!-- body elements must be BEFORE script so that
     getElementById can be used to set global vars -->

<?php

    $agent = $_SERVER['HTTP_USER_AGENT'];
    $ok = false;
    foreach ( $epm_supported_browsers as $b )
    {
        if ( preg_match ( "/$b/i", $agent ) )
	{
	    $ok = true;
	    break;
	}
    }
    if ( ! $ok )
    {
        $ok_browsers =
	    implode ( ",", $epm_supported_browsers );
	echo <<<EOT
	<mark>$agent is an untested browser type.<br>
	      If it does not work use one of:
	         $ok_browsers.</mark><br><br>
EOT;
    }
?>

<div id='get_email' style.display='none'>
<table style='width:100%'>
<tr><td style='width:90%'>
<input type='text' id='email_in'
       placeholder='Enter Email Address'
       autofocus
       title='address (to be) associated with account'>
</td><td style='width:10%;text-align:right'>
<button type='button' onclick='HELP("login-page")'>
?</button>
</td></tr></table>
<br>
<strong>New Users - See
        <a href='/page/guide.html'>Guide</a></strong>
</div>

<div id='show_email' style.display='none'>
<table style='width:100%'>
<tr><td style='width:90%'>
<strong>Email:<pre>   </pre>
<span id='email_out'></span></strong>
</td><td style='width:10%;text-align:right'>
<button type='button' onclick='HELP("login-page")'>
?</button>
</td></tr></table>
<br>
<button type='button'
        onclick="location.reload(true)">
Change Email Address
</button>
</div>

<div id='get_cnum' style.display='none'>
A Confirmation Number has been sent
to the above Email Address.
<br>
<br>
Please <input type='text' size='40' id='cnum_in'
       placeholder='Enter Confirmation Number'>
</div>


<?php
    $f = "admin/motd.html";
    if ( file_exists ( "$epm_data/$f" ) )
    {
	echo "<div class='terms'>";
        include "$epm_data/$f";
	echo "</div>";
    }
?>
<div class='terms'>
<?php require __DIR__ . '/../include/epm_terms.html'; ?>
</div>

<script>

var LOG = function(message) {};
<?php if ( $epm_debug )
          echo "LOG = console.log;" . PHP_EOL ?>

var ID = '<?php echo $ID; ?>';
var xhttp = new XMLHttpRequest();
var storage = window.localStorage;
var get_email = document.getElementById("get_email");
var email_in = document.getElementById("email_in");
var email_out = document.getElementById("email_out");
var show_email = document.getElementById("show_email");
var get_cnum = document.getElementById("get_cnum");
var cnum_in = document.getElementById("cnum_in");


function ALERT ( message )
{
    // Alert must be scheduled as separate task.
    //
    setTimeout ( function () { alert ( message ); } );
}

function FAIL ( message )
{
    alert ( message );
    location.reload();
}

var REQUEST_IN_PROGRESS = false;
var RESPONSE = '';  // Saved here for error messages.
function SEND ( data, callback, error_message )
{
    xhttp.onreadystatechange = function() {
	LOG ( 'xhttp state changed to state '
	      + this.readyState );
	if ( this.readyState !== XMLHttpRequest.DONE
	     ||
	     ! REQUEST_IN_PROGRESS )
	    return;

	if ( this.status != 200 )
	    FAIL ( 'Bad response status ('
	           + this.status
	           + ') from server on '
	           + error_message );

	REQUEST_IN_PROGRESS = false;
	LOG ( 'xhttp response: '
	      + this.responseText );
	RESPONSE = this.responseText;
	item = RESPONSE.trim().split ( ' ' );
	ID = item.shift();
	if ( ID == undefined )
	    FAIL ( 'empty response' );
	callback ( item );
    };
    xhttp.open ( 'POST', "login.php", true );
    xhttp.setRequestHeader
        ( "Content-Type",
	  "application/x-www-form-urlencoded" );
    REQUEST_IN_PROGRESS = true;
    data += '&xhttp=yes&id=' + ID;
    LOG ( 'xhttp sent: ' + data );
    xhttp.send ( data );
}
function MALFORMED_RESPONSE ( when )
{
    FAIL ( "malformed response `" + RESPONSE +
           "' " + when );
}

let PATH = location.pathname;
var AUTO_RETRY, EMAIL, BID;

var GET_EMAIL_ENABLED = false;
var GET_CNUM_ENABLED = false;
    // These are set to true to enable callback, and
    // set false just before making callback, to avoid
    // spurious callbacks.

// BEGIN:
//
GET_EMAIL_ENABLED = true;
get_email.style.display = 'block';
show_email.style.display = 'none';
get_cnum.style.display = 'none';

function EMAIL_KEYDOWN ( event )
{
    if ( event.code == 'Enter'
         &&
	 GET_EMAIL_ENABLED )
    {
	var value = email_in.value.trim();
	if ( /^\S+@\S+\.\S+$/.test(value) )
	{
	    GET_EMAIL_ENABLED = false;
	    GOT_EMAIL ( value );
	}
	else if ( value != '' )
	    ALERT ( value + " is not a valid" +
	            " email address" );
    }
}
email_in.addEventListener ( 'keydown', EMAIL_KEYDOWN );

function GOT_EMAIL ( email )
{
    EMAIL = email;
    get_email.style.display = 'none';
    email_out.innerText = EMAIL;
    show_email.style.display = 'block';
    BID = storage.getItem(PATH + '\0' + EMAIL);
    if ( BID == null )
        MANUAL_ID();
    else
	AUTO_ID();
}

function MANUAL_ID()
{
    SEND ( "op=MANUAL&value="
           + encodeURIComponent ( EMAIL ),
           MANUAL_RESPONSE,
	   'sending ' + EMAIL + ' to server' );
}

function MANUAL_RESPONSE ( item )
{
    if ( item.length != 1 )
        MALFORMED_RESPONSE
	    ( 'after sending ' + EMAIL + ' to server' );
    else if ( item[0] == 'BAD_EMAIL' )
        FAIL ( EMAIL +
	       ' is not a valid email address' );
    else if ( item[0] == 'BLOCKED_EMAIL' )
        FAIL ( EMAIL + ' is blocked' );
    else if ( item[0] == 'NEW' )
        CONFIRM();
    else
        MALFORMED_RESPONSE
	    ( 'after sending ' + EMAIL + ' to server' );
};

function CONFIRM()
{
    GET_CNUM_ENABLED = true;
    get_cnum.style.display = 'block';
}

function CNUM_KEYDOWN ( event )
{
    if ( event.code == 'Enter'
         &&
	 GET_CNUM_ENABLED )
    {
	value = cnum_in.value.trim();
	if ( /^[a-fA-F0-9]{32}$/.test(value) )
	{
	    GET_CNUM_ENABLED = false;
	    GOT_CNUM ( value );
	}
	else if ( value != '' )
	    ALERT ( value + ' is not a valid' +
	            ' confirmation number' );
    }
}
cnum_in.addEventListener ( 'keydown', CNUM_KEYDOWN );

function GOT_CNUM ( cnum )
{
    BID = cnum;
    AUTO_ID();
}

function AUTO_ID()
{
    storage.removeItem ( PATH + '\0' + EMAIL );
    SEND ( 'op=AUTO&value=' + BID,
           AUTO_RESPONSE,
	   'auto-login' );
}

function AUTO_RESPONSE ( item )
{
    if ( item[0] == 'EXPIRED' )
        CONFIRM();
    else if ( item[0] == 'FAIL' )
        MANUAL_ID();
    else if ( item[0] == 'BLOCKED_EMAIL' )
        FAIL ( EMAIL + ' is blocked' );
    else if ( item[0] == 'RENEW'
              &&
	      item.length == 3 )
    {
	BID = item[1];
	if ( ! /^[a-fA-F0-9]{32}$/.test(BID) )
	    MALFORMED_RESPONSE ( 'to auto-login' );
	storage.setItem ( PATH + '\0' + EMAIL, BID );

	try {
	    window.location.assign
	        ( item[2] + '?id=' + ID );
	} catch ( e ) {
	    FAIL
	       ( 'could not access page ' + item[2] );
	       // On retry login.php will go to
	       // correct page.
	}
    }
    else
	MALFORMED_RESPONSE
	    ( 'to auto-login' );
}
    
</script>


</body>
</html>
